//
//  CubeService.swift
//  Lucuber
//  Created by Tychooo on 16/9/19.
//  Copyright © 2016年 Tychooo. All rights reserved.

import Foundation
import AVOSCloud
import RealmSwift


public enum ErrorCode: String {
    case blockedByRecipient = "rejected_your_message"
    case notYetRegistered = "not_yet_registered"
    case userWasBlocked = "user_was_blocked"
    case userIsRegister = "手机号码已经注册"
}

public enum Reason: CustomStringConvertible {
    case network(Error?)
    case noData
    case noSuccessStatusCode(statusCode: Int, errorCode: ErrorCode?)
    case noSuccess
    case other(NSError?)
    
    public var description: String {
        switch self {
        case .network(let error):
            return "Network, Error: \(error)"
        case .noData:
            return "NoData"
        case .noSuccessStatusCode(let statusCode):
            return "NoSuccessStatusCode: \(statusCode)"
        case .noSuccess:
            return "NoSuccess"
        case .other(let error):
            return "Other, Error: \(error)"
        }
    }
}


public typealias FailureHandler = (_ reason: Reason, _ errorMessage: String?) -> Void

public let defaultFailureHandler: FailureHandler = { (reason, errorMessage) in
    print("\n***************************** Lucuber Failure *****************************")
    print("Reason: \(reason)")
    if let errorMessage = errorMessage { print("errorMessage: >>>\(errorMessage)<<<\n") }
}

public func pushToLeancloud(with images: [UIImage], quality: CGFloat, completion: (([String]) -> Void)?, failureHandler: ((NSError?) -> Void)?) {
    
    guard !images.isEmpty else {
        return
    }
    
    var imagesURL = [String]()
    images.forEach { image in
        
        if let data = UIImageJPEGRepresentation(image, quality) {
            let uploadFile = AVFile(data: data)
            
            var error: NSError?
            if uploadFile.save(&error) {
                if let url = uploadFile.url {
                    imagesURL.append(url)
                }
            } else {
                failureHandler?(error)
            }
        }
    }
    
    completion?(imagesURL)
}

public func pushToMasterListLeancloud(with masterList: [String], completion: (() -> Void)?, failureHandler: ((Error?) -> Void)?) {
    
    guard let currenUser = AVUser.current() else {
        return
    }
    currenUser.setMasterList(masterList)
    currenUser.saveEventually()
    
}


public func pushDataToLeancloud(with data: Data?, failureHandler: @escaping FailureHandler, completion: @escaping (_ URLString: String) -> Void) {
    
    guard let data = data else {
        failureHandler(Reason.noData, "传入的 Data 为空")
        return
    }
    
    let file = AVFile(data: data)
    file.saveInBackground { success, error in
        if success {
            completion(file.url ?? "")
        }
        if error != nil {
            failureHandler(Reason.network(error), "网络请求失败")
        }
    }
}



public func pushMessageImage(atPath filePath: String?, orFileData fileData: Data?, metaData: String?, toRecipient recipientID: String, recipientType: String, afterCreatedMessage: @escaping (Message) -> Void, failureHandler: @escaping FailureHandler, completion: @escaping (Bool) -> Void) {
    
    createAndPushMessage(with: MessageMediaType.image, atFilePath: filePath, orFileData: fileData, metaData: metaData, text: "", toRecipient: recipientID, recipientType: recipientType, afterCreatedMessage: afterCreatedMessage, failureHandler: failureHandler, completion: completion)
}

public func pushMessageText(_ text: String, toRecipient recipientID: String, recipientType: String, afterCreatedMessage: @escaping (Message) -> Void,failureHandler: @escaping FailureHandler, completion: @escaping (Bool) -> Void) {
    
    createAndPushMessage(with: MessageMediaType.text, atFilePath: nil, orFileData: nil, metaData: nil, text: text, toRecipient: recipientID, recipientType: recipientType, afterCreatedMessage: afterCreatedMessage, failureHandler: failureHandler, completion: completion)
}

public func pushMessageAudio(atPath filePath: String?, orFileData fileData: Data?, metaData: String?, toRecipient recipientID: String, recipientType: String, afterCreatedMessage: @escaping (Message) -> Void, failureHandler: @escaping FailureHandler, completion: @escaping (Bool) -> Void ) {
    
    createAndPushMessage(with: MessageMediaType.audio, atFilePath: filePath, orFileData: fileData, metaData: metaData, text: "", toRecipient: recipientID, recipientType: recipientType, afterCreatedMessage: afterCreatedMessage, failureHandler: failureHandler, completion: completion)
}


public func createAndPushMessage(with mediaType: MessageMediaType, atFilePath filePath: String?, orFileData fileData: Data?, metaData: String?, text: String, toRecipient recipientID: String, recipientType: String, afterCreatedMessage: (Message) -> Void, failureHandler: @escaping FailureHandler, completion: @escaping (Bool) -> Void) {
    
    // 因为 message_id 必须来自远端，线程无法切换，所以这里暂时没用 realmQueue
    // TOOD: 也许有办法
    guard let realm = try? Realm() else {
        return
    }
    // 创建新的实例
    let message = Message()
    message.localObjectID = Message.randomLocalObjectID()
    
    // 保证创建的新消息时间为最最最最新
    if let latestMessage = realm.objects(Message.self).sorted(byProperty: "createdUnixTime", ascending: true).last {
        
        if message.createdUnixTime < latestMessage.createdUnixTime {
            message.createdUnixTime = latestMessage.createdUnixTime + 0.0005
        }
    }
    
    message.mediaType = mediaType.rawValue
    message.downloadState = MessageDownloadState.downloaded.rawValue
    //    message.sendStateInt = MessageSendState.notSend.rawValue
    message.readed = true
    
    
    // 添加到 Realm
    try? realm.write {
        realm.add(message)
    }
    
    
    if let me = currentUser(in: realm) {
        try? realm.write {
            message.creator = me
        }
    }
    
    
    // 如果没有 Conversation ，创建
    var conversation: Conversation? = nil
    
    try? realm.write {
        
        if recipientType == "user" {
            
            if let withFriend = userWith(recipientID, inRealm: realm) {
                conversation = withFriend.conversation
            }
            
        } else {
            
            if let withGroup = groupWith(recipientID, inRealm: realm) {
                conversation = withGroup.conversation
            }
        }
        
        if conversation == nil {
            
            let newConversation = Conversation()
            
            if recipientType == "user" {
                
                newConversation.type = ConversationType.oneToOne.rawValue
                
                if let withFriend = userWith(recipientID, inRealm: realm) {
                    newConversation.withFriend = withFriend
                }
                
            } else {
                
                newConversation.type = ConversationType.group.rawValue
                
                if let withGroup = groupWith(recipientID, inRealm: realm) {
                    newConversation.withGroup = withGroup
                }
            }
            
            conversation = newConversation
        }
        
        if let conversation = conversation {
            
            message.conversation = conversation
            
            tryCreatDateSectionMessage(with: conversation, beforeMessage: message, inRealm: realm) {
                sectionDateMessage in
                realm.add(sectionDateMessage)
            }
            
            conversation.updateUnixTime = Date().timeIntervalSince1970
            
            DispatchQueue.main.async {
                
            }
            
            message.recipientID = recipientID
            message.recipientType = recipientType
            
            
            // 发送通知, Convertaion 有新的
        }
        
    }
    
    // TODO: - 处理 Location
    
    try? realm.write {
        message.textContent = text
    }
    
    afterCreatedMessage(message)
    
    
    // TODO: - 音效处理
    
    
    // push 到远端
    
    
    pushMessageToLeancloud(with: message, atFilePath: filePath, orFileData: fileData, metaData: metaData, toRecipient: recipientID, recipientType: recipientType, failureHandler: {
        reason, errorMessage in
        
        failureHandler(reason, errorMessage)
        
        let realm = message.realm
        try? realm?.write {
            message.lcObjectID = ""
            message.sendState = MessageSendState.failed.rawValue
        }
        
    }, completion: completion)
    
}

public func pushMessageToLeancloud(with message: Message, atFilePath filePath: String?, orFileData fileData: Data?, metaData: String?, toRecipient recipientID: String, recipientType: String, failureHandler: @escaping FailureHandler, completion: @escaping (Bool) -> Void) {
    
    guard let mediaType = MessageMediaType(rawValue: message.mediaType) else {
        printLog("无效的 mediaType")
        return
    }
    
    // 缓存池保存待发送的 Message
    SendingMessagePool.addMessage(with: message.localObjectID)
    
    let discoverMessage = parseMessageToDisvocerModel(with: message)
    
    let messageSavedCompletion: AVBooleanResultBlock = { success, error in
        if success {
            
            let realm = message.realm
            try? realm?.write {
                message.lcObjectID = discoverMessage.objectId ?? ""
                message.sendState = MessageSendState.successed.rawValue
            }
            completion(success)
        }
        
        if error != nil { failureHandler(Reason.network(error), "网络请求失败") }
    }
    
    // TODO: - 暂时不处理 Location
    switch mediaType {
        
    case .text:
        discoverMessage.saveInBackground(messageSavedCompletion)
        
    case .audio, .image, .video:
        
        pushDataToLeancloud(with: fileData, failureHandler: { reason, errorMessage in
            
            failureHandler(reason, errorMessage)
            
        }, completion: { URLString in
            
            discoverMessage.attachmentURLString = URLString
            
            let realm = message.realm
            try? realm? .write {
                message.attachmentURLString = URLString
            }
            
            discoverMessage.saveInBackground(messageSavedCompletion)
            
        })
        
    default:
        break
    }
}

public func pushFormulaToLeancloud(with newFormula: Formula, failureHandler: @escaping FailureHandler , completion: (() -> Void)?) {
    
    guard let newDiscoverFormula = parseFormulaToDisvocerModel(with: newFormula) else  {
        failureHandler(Reason.other(nil), "模型转换失败")
        return
    }
    
    let saveAllObject: AVBooleanResultBlock = { success, error in
        
        if error != nil {
            failureHandler(Reason.network(error), "推送 Formula 的 contents 失败.")
        }
        
        if success {
            
            newDiscoverFormula.saveInBackground({ success, error in
                
                if error != nil {
                    failureHandler(Reason.network(error), "推送 Formula 失败")
                }
                
                if success {
                    
                    guard let realm = newFormula.realm else {
                        failureHandler(Reason.other(nil), "上传成功, 但以无法找到 newFormula 对应的 realm")
                        return }
                    
                    try? realm.write {
                        
                        if newDiscoverFormula.contents.count == newFormula.contents.count {
                            
                            for index in 0..<newDiscoverFormula.contents.count {
                                if let lcObjectID = newDiscoverFormula.contents[index].objectId {
                                    newFormula.contents[index].lcObjectID = lcObjectID
                                }
                            }
                        }
                        
                        newFormula.isPushed = true
                        newFormula.lcObjectID = newDiscoverFormula.objectId!
                        createOrUpdateRCategory(with: newFormula, uploadMode: .my, inRealm: realm)
                    }
                    
                    completion?()
                }
                
            })
        }
        
    }
    
    var newImageData: Data?
    var newResizeImage: UIImage?
    
    if let newImage = newFormula.pickedLocalImage {
        
        newResizeImage = newImage.resizeTo(targetSize: CGSize(width: 600, height: 600), quality: CGInterpolationQuality.medium)!
        newImageData = UIImagePNGRepresentation(newResizeImage!)
    }
    
    if let localImageURL = FileManager.cubeFormulaLocalImageURL(with: newFormula.localObjectID) {
        
        if let image = UIImage(contentsOfFile: localImageURL.path) {
            
            newResizeImage = image
            newImageData = UIImagePNGRepresentation(newResizeImage!)
        }
        
    }
    
    // 有新图片, 先上传图片
    if let newImageData = newImageData {
        
        pushDataToLeancloud(with: newImageData, failureHandler: {
            reason, errorMessage in
            
            failureHandler(reason, errorMessage)
            
        }, completion: { imageURLString in
            
            newDiscoverFormula.imageURL = imageURLString
            
            let realm = newFormula.realm
            try? realm?.write {
                newFormula.imageURL = imageURLString
            }
            
            if let newResizeImage = newResizeImage {
                
                CubeImageCache.shard.storeAlreadyUploadImageToCache(with: newResizeImage, imageExtension: CubeImageCache.imageExtension.png, imageURLString: imageURLString)
                
                FileManager.removeFormulaLocalImageData(with: newFormula.localObjectID)
            }
            
            AVObject.saveAll(inBackground: newDiscoverFormula.contents, block: saveAllObject)
            
        })
        
    // 没有新图片, 一定有老图片
    } else {
        
        newDiscoverFormula.imageURL = newFormula.imageURL
        AVObject.saveAll(inBackground: newDiscoverFormula.contents, block: saveAllObject)
        
    }
    
}

public func pushCurrentUserUpdateInformation() {
    
    guard let realm = try? Realm() else {
        return
    }
    
    if let currentUser = currentUser(in: realm) {
        // 更新用户修改的公式
        let unPusheFormula = unPushedFormula(with: currentUser, inRealm: realm)
        
        if !unPusheFormula.isEmpty {
            
            for formula in unPusheFormula {
                
                pushFormulaToLeancloud(with: formula, failureHandler: {
                    reason, errorMessage in
                    
                    defaultFailureHandler(reason, errorMessage)
                    
                }, completion: {
                    _ in
                    printLog("更新公式信息到Leancloud成功")
                })
            }
        }
        // Leanclooud 断标记删除的内容
        let deletedFormula = deleteByCreatorFormula(with: currentUser, inRealm: realm)
        var discoverFormulas = [DiscoverFormula]()
        
        if !deletedFormula.isEmpty {
            
            for formula in deletedFormula {
                
                if formula.lcObjectID == "" {
                    
                    try? realm.write {
                        realm.delete(formula)
                    }
                    
                } else {
                    
                    let discoverFormula = DiscoverFormula(className: "DiscoverFormula", objectId: formula.lcObjectID)
                    
                    discoverFormula.setValue(true, forKey: "deletedByCreator")
                    
                    discoverFormulas.append(discoverFormula)
                }
            }
        }
        
        if !discoverFormulas.isEmpty {
            
            AVObject.saveAll(inBackground: discoverFormulas, block: { success, error in
                
                
                if error != nil {
                    defaultFailureHandler(Reason.network(error), "删除公式推送失败")
                }
                
                if success {
                    printLog("删除公式推送成功, 共删除 \(discoverFormulas.count) 个公式")
                    try? realm.write {
                        realm.delete(deletedFormula)
                    }
                }
                
            })
        }
        
        let deletedContents = deleteByCreatorRContent(with: currentUser, inRealm: realm)
        
        var discoverContents = [DiscoverContent]()
        if !deletedContents.isEmpty {
            
            for content in deletedContents {
                
                if content.lcObjectID == "" {
                    try? realm.write {
                        realm.delete(content)
                    }
                    
                } else {
                    
                    let discoverContent = DiscoverContent(className: "DiscoverContent", objectId: content.lcObjectID)
                    discoverContent.setValue(true, forKey: "deletedByCreator")
                    discoverContents.append(discoverContent)
                }
            }
        }
        
        if !discoverContents.isEmpty {
            
            AVObject.saveAll(inBackground: discoverContents, block: { success, error in
                
                if error != nil {
                    defaultFailureHandler(Reason.network(error), "删除公式Content推送失败")
                }
                
                if success {
                    printLog("删除公式Content信息推送成功, 共删除 \(discoverContents.count) 个Content")
                    try? realm.write {
                        realm.delete(deletedContents)
                    }
                }
            })
        }
        
    }
}


public enum UploadFeedMode {
    case top
    case loadMore
}

//extension AVQuery {
//
//     enum DefaultKey: String {
//        case updatedTime = "updatedAt"
//        case creatTime = "createdAt"
//    }
//
//    class func getFormula(mode: UploadFormulaMode) -> AVQuery {
//
//        switch mode {
//
//        case .my:
//
//            let query = AVQuery(className: DiscoverFormula.parseClassName())
//            query.addAscendingOrder("name")
//            query.whereKey("creator", equalTo: AVUser.current()!)
//            
//            query.limit = 1000
//            return query
//            
//        case .library:
//            
//            let query = AVQuery(className: DiscoverFormula.parseClassName())
//            query.whereKey("isLibrary", equalTo: NSNumber(booleanLiteral: true))
//            query.addAscendingOrder("serialNumber")
//            query.limit = 1000
//            return query
//            
//        }
//    }
//    
// 
//    
//}

//func fetchFormulaWithMode(uploadingFormulaMode: UploadFormulaMode,
//                                 category: Category,
//                                 completion: (([Formula]) -> Void)?,
//                                 failureHandler: ((NSError?) -> Void)?) {
//    
//    switch uploadingFormulaMode {
//        
//    case .my :
//        
//        let query = AVQuery.getFormula(mode: uploadingFormulaMode)
//        
//        printLog("-> 开始获取我的公式")
//        query.findObjectsInBackground { formulas, error in
//            
//            if error != nil {
//                
//                failureHandler?(error as? NSError)
//                let result = getFormulsFormRealmWithMode(mode: uploadingFormulaMode, category: category)
////                completion?(result)
//                printLog("更新我的公式失败， 使用 Realm 中的我的公式")
// 
//            }
//            
//            if let formulas = formulas as? [Formula] {
//                
//                /// 将 Result 过滤一下, 只使用符合 category 的 formula
//                completion?(formulas.filter{ $0.category == category })
//                
//                /// 删除 Library 中 Formula 对应的 content
//                deleteMyFormulasRContentAtRealm()
//                
//                /// 更新数据库中的 Formula
////                saveUploadFormulasAtRealm(formulas: formulas, mode: uploadingFormulaMode, isCreatNewFormula: false)
//                
//                printLog("-> 成功更新我的公式")
//                
//            }
//        }
//        
//    case .library:
//        
//        // 公式库, 如果Realm中没有数据, 则尝试从网络加载, 否则不需要从网络加载
//        let result = getFormulsFormRealmWithMode(mode: uploadingFormulaMode, category: category)
//        
//        if result.isEmpty {
//            
//            
//            failureHandler?(nil)
//            NotificationCenter.default.post(name: Notification.Name.updateFormulasLibraryNotification, object: nil)
//            
//        } else {
//            
////            completion?(result)
//        }
//        
//    }
//
//}


//public func fetchLibraryFormulaFormLeanCloudAndSaveToRealm(completion: (() -> Void)?, failureHandler: ((NSError) -> Void)?) {
//    
//    
//    let query = AVQuery.getFormula(mode: .library)
//    
//    query.findObjectsInBackground { formulas, error in
//        
//        if error != nil {
//            
//            failureHandler?(error as! NSError)
//        }
//        
//        if let formulas = formulas as? [Formula] {
//            
//            if let user = AVUser.current() {
//                
//                user.setNeedUpdateLibrary(need: false)
//                user.saveEventually { successed, error in
//                    
//                    if successed {
//                        printLog("更新 currentUser 的 needUploadLibrary 属性为 false")
//                        
//                    } else {
//                        printLog("更新 currentUser 的 needUploadLibrary 属性失败")
//                    }
//                }
//            }
//            
//            deleteLibraryFormalsRContentAtRealm()
//            
////            saveUploadFormulasAtRealm(formulas: formulas, mode: .library, isCreatNewFormula: false)
//            
//            completion?()
//            
//        }
//    }
//    
//}


//internal func saveNewFormulaToRealmAndPushToLeanCloud(newFormula: Formula,
//                                                      completion: (() -> Void)?,
//                                                      failureHandler: ((NSError) -> Void)? ) {
//    
//    if let user = AVUser.current() {
//        
//        newFormula.creatUser = user
//        newFormula.creatUserID = user.objectId!
//        
//        let acl = AVACL()
//        acl.setPublicReadAccess(true)
//        acl.setWriteAccess(true, for: AVUser.current()!)
//        newFormula.acl = acl
//        
//        
//        newFormula.saveEventually({ (success, error) in
//            if error  == nil {
//                printLog("新公式保存到 LeanCloud 成功")
//            } else {
//                printLog("新公式保存到 LeanCloud 失败")
//            }
//        })
//        
//        saveUploadFormulasAtRealm(formulas: [newFormula], mode: nil, isCreatNewFormula: true)
//        
//        
//        completion?()
//        
//        
//    } else {
//        
//        let error = NSError(domain: "没有登录用户", code: 0, userInfo: nil)
//        failureHandler?(error)
//    }
//    
//    
//    
//}

// MARK: - Register

public func fetchValidateMobile(mobile: String, checkType: LoginType, failureHandler: @escaping FailureHandler, completion: @escaping (() -> Void)) {
    
    let query = AVQuery(className: "_User")
    query.whereKey("mobilePhoneNumber", equalTo: mobile)
    
    query.findObjectsInBackground { users, error in
        
        switch checkType {
            
        case .register:
            
            if let resultUsers = users {
                
                if let user = resultUsers.first as? AVUser, let _ = user.nickname() {
                    
                    failureHandler(Reason.noSuccess, "您输入的手机号码已经注册, 请返回登录")
                    
                } else { completion() }
                
            } else { completion() }
            
            if error != nil {
                
                failureHandler(Reason.network(error), "网络请求失败, 请稍后再试")
            }
            
            
        case .login:
            
            if let resultUsers = users {
               
                if let user = resultUsers.first as? AVUser, let _ = user.nickname() {
                    completion()
                    
                } else {
                   
                    failureHandler(Reason.noSuccess, "您输入的手机号码尚未注册, 请返回注册")
                }
            }
            if error != nil {
                
                failureHandler(Reason.network(error), "网络请求失败, 请稍后再试")
            }
        }
    }
}


/// 获取短信验证码
public func fetchMobileVerificationCode(phoneNumber: String, failureHandler: @escaping FailureHandler, completion: (() -> Void)? ) {
    
    AVOSCloud.requestSmsCode(withPhoneNumber: phoneNumber) { success, error in
        if success { completion?() }
        if error != nil { failureHandler(Reason.other(error as? NSError), nil) }
    }
}


/// 注册登录
public func signUpOrLogin(with phoneNumber: String, smsCode: String,  failureHandler: @escaping FailureHandler, completion: ((AVUser) -> Void)? ) {
    
    AVUser.signUpOrLoginWithMobilePhoneNumber(inBackground: phoneNumber, smsCode: smsCode) { user, error in
        
        if let user = user { completion?(user) }
        if error != nil { failureHandler(Reason.other(error as? NSError), nil) }
    }
}


/// Logout
public func logout() {
    AVUser.logOut()
}


// Message


//
//func convertToLeanCloudMessageAndSend(message: Message, failureHandler: (() -> Void)?, completion: ((Bool) -> Void)? ) {
//    
//    let discoverMessage = parseMessageToDisvocerModel(with: message)
//    
//    discoverMessage.saveInBackground {
//        successed, error in
//        
//        if error != nil {
//            // 标记发送失败
//            guard let realm = try? Realm() else {
//                failureHandler?()
//                return
//            }
//            
//            try? realm.write {
//                message.sendStateInt = MessageSendState.failed.rawValue
//            }
//            
//            failureHandler?()
//            
//        }
//        
//        if successed {
//            printLog("发送成功")
//            
//            guard let realm = try? Realm() else {
//                
//                failureHandler?()
//                return
//            }
//            
//            try? realm.write {
//                message.sendStateInt = MessageSendState.successed.rawValue
//                message.messageID = leanCloudMessage.objectId!
//            }
//            
//            completion?(successed)
//        }
//        
//        // 通知 Cell 更改发送状态提示.
//        NotificationCenter.default.post(name: Notification.Name.updateMessageStatesNotification, object: nil)
//        
//    }
//    
//}

// Feed

//internal func fetchFeedWithCategory(category: FeedCategory,
//                                    uploadingFeedMode: UploadFeedMode,
//                                    lastFeedCreatDate: NSDate,
//                                    completion: (([Feed]) -> Void)?,
//                                    failureHandler: ((NSError) -> Void)? ) {
//    
//    let query = AVQuery(className: Feed.parseClassName())
//    query.addDescendingOrder(AVQuery.DefaultKey.updatedTime.rawValue)
//    query.limit = 10
//    
//    switch category {
//        
//    case .All:
//        // Do Noting
//        break
//        
//    case .Topic:
//        // Do Noting
//        break
//        
//    case .Formula:
//        query.whereKey(Feed.Feedkey_category, equalTo: FeedCategory.Formula.rawValue)
//        
//    case .Record:
//        query.whereKey(Feed.Feedkey_category, equalTo: FeedCategory.Record.rawValue)
//        
//    }
//    
//    switch uploadingFeedMode {
//        
//    case .top:
//        // Do Noting
//        break
//        
//    case .loadMore:
//        query.whereKey(AVQuery.DefaultKey.creatTime.rawValue, lessThan: lastFeedCreatDate)
//    }
//    
//    query.findObjectsInBackground { newFeeds, error in
//        
//        if error != nil {
//            
//            failureHandler?(error as! NSError)
//            
//        } else {
//            
//            if let newFeeds = newFeeds as? [Feed] {
//                
//                //                printLog("newFeeds.count = \(newFeeds.count)")
//                completion?(newFeeds)
//            }
//        }
//    }
//    
//}


















